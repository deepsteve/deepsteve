<!DOCTYPE html>
<html>
<head>
  <title>deepsteve</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
  <style>
    * { margin: 0; box-sizing: border-box; }
    body { background: #0d1117; color: #c9d1d9; font-family: system-ui; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
    #tabs { display: flex; gap: 2px; padding: 4px 8px; background: #161b22; align-items: center; flex-shrink: 0; }
    .tab { padding: 6px 12px; background: #21262d; border: 1px solid #30363d; border-radius: 6px 6px 0 0; cursor: pointer; color: #8b949e; font-size: 13px; display: flex; align-items: center; gap: 6px; }
    .tab.active { background: #0d1117; color: #f0f6fc; border-bottom-color: #0d1117; }
    .tab .close { opacity: 0.5; cursor: pointer; font-size: 11px; }
    .tab .close:hover { opacity: 1; color: #f85149; }
    /* Context Menu */
    .context-menu { position: fixed; background: #161b22; border: 1px solid #30363d; border-radius: 6px; padding: 4px 0; min-width: 140px; z-index: 200; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
    .context-menu-item { padding: 8px 12px; cursor: pointer; font-size: 13px; color: #c9d1d9; }
    .context-menu-item:hover { background: #21262d; }
    #new-btn { padding: 4px 10px; background: #238636; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 13px; margin-left: 4px; }
    #new-btn:hover { background: #2ea043; }
    .terminal-container { flex: 1; display: none; }
    .terminal-container.active { display: block; }
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 100; }
    .modal { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 20px; width: 420px; }
    .modal h2 { font-size: 16px; margin-bottom: 16px; color: #f0f6fc; }
    .path-wrap { display: flex; gap: 8px; margin-bottom: 8px; }
    .modal input[type="text"] { flex: 1; padding: 8px 12px; background: #0d1117; border: 1px solid #30363d; border-radius: 4px; color: #c9d1d9; font-size: 13px; font-family: monospace; }
    .modal input[type="text"]:focus { outline: none; border-color: #238636; }
    .path-up, .new-folder { padding: 8px 12px; background: #21262d; border: 1px solid #30363d; border-radius: 4px; cursor: pointer; color: #8b949e; }
    .path-up:hover, .new-folder:hover { background: #30363d; color: #c9d1d9; }
    .dir-tree { background: #0d1117; border: 1px solid #30363d; border-radius: 4px; max-height: 240px; overflow-y: auto; margin-bottom: 12px; }
    .dir-item { padding: 8px 12px; cursor: pointer; font-size: 13px; font-family: monospace; color: #c9d1d9; display: flex; align-items: center; gap: 8px; border-bottom: 1px solid #21262d; }
    .dir-item:last-child { border-bottom: none; }
    .dir-item:hover { background: #21262d; }
    .dir-icon { opacity: 0.6; }
    .dir-empty { padding: 16px; text-align: center; color: #8b949e; font-size: 13px; }
    .modal label { display: flex; align-items: center; gap: 8px; font-size: 13px; color: #8b949e; margin-bottom: 16px; cursor: pointer; }
    .modal input[type="checkbox"] { accent-color: #238636; }
    .modal-buttons { display: flex; gap: 8px; justify-content: flex-end; }
    .modal button { padding: 6px 14px; border-radius: 4px; border: 1px solid #30363d; cursor: pointer; font-size: 13px; }
    .modal .btn-primary { background: #238636; color: white; border-color: #238636; }
    .modal .btn-primary:hover { background: #2ea043; }
    .modal .btn-secondary { background: #21262d; color: #c9d1d9; }
    .modal .btn-secondary:hover { background: #30363d; }
  </style>
</head>
<body>
  <div id="tabs"><button id="new-btn">+ New</button></div>
  <div id="terminals"></div>
  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
  <script>
    const sessions = new Map();
    let activeId = null;
    const STORAGE_KEY = 'deepsteve';
    function getStorage() { try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; } catch { return {}; } }
    function setStorage(data) { localStorage.setItem(STORAGE_KEY, JSON.stringify({ ...getStorage(), ...data })); }

    // === Tab Context Menu ===
    const TabContextMenu = {
      // Menu item definitions - add new options here
      items: [
        { label: 'Rename', action: (id) => TabContextMenu.renameTab(id) }
        // Add more menu items here: { label: 'Copy Path', action: (id) => ... }
      ],

      show(x, y, sessionId) {
        this.hide();
        const menu = document.createElement('div');
        menu.className = 'context-menu';
        menu.id = 'tab-context-menu';
        this.items.forEach(item => {
          const el = document.createElement('div');
          el.className = 'context-menu-item';
          el.textContent = item.label;
          el.onclick = () => { this.hide(); item.action(sessionId); };
          menu.appendChild(el);
        });
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        document.body.appendChild(menu);
        // Adjust if off-screen
        const rect = menu.getBoundingClientRect();
        if (rect.right > window.innerWidth) menu.style.left = (window.innerWidth - rect.width - 8) + 'px';
        if (rect.bottom > window.innerHeight) menu.style.top = (window.innerHeight - rect.height - 8) + 'px';
      },

      hide() {
        document.getElementById('tab-context-menu')?.remove();
      },

      renameTab(id) {
        const session = sessions.get(id);
        if (!session) return;
        const newName = prompt('Rename tab:', session.name || '');
        if (newName === null) return;
        session.name = newName.trim() || getDefaultTabName(session.cwd);
        updateTabLabel(id);
        saveSessionName(id, session.name);
      }
    };

    document.addEventListener('click', () => TabContextMenu.hide());
    document.addEventListener('contextmenu', (e) => { if (!e.target.closest('.tab')) TabContextMenu.hide(); });

    function getDefaultTabName(cwd) {
      if (!cwd) return 'shell';
      return cwd.split('/').filter(Boolean).pop() || 'root';
    }

    function updateTabLabel(id) {
      const tab = document.getElementById('tab-' + id);
      const session = sessions.get(id);
      if (tab && session) {
        tab.querySelector('.tab-label').textContent = session.name || getDefaultTabName(session.cwd);
      }
    }

    function saveSessionName(id, name) {
      const storage = getStorage();
      const saved = storage.sessions || [];
      const session = saved.find(s => s.id === id);
      if (session) { session.name = name; setStorage({ sessions: saved }); }
    }

    function getSavedSessionName(id) {
      const storage = getStorage();
      const saved = storage.sessions || [];
      const session = saved.find(s => s.id === id);
      return session?.name;
    }
    async function fetchDirs(p) { try { const r = await fetch('/api/dirs?path=' + encodeURIComponent(p)); return await r.json(); } catch { return { dirs: [] }; } }
    async function fetchHome() { try { const r = await fetch('/api/home'); return (await r.json()).home; } catch { return '/Users'; } }
    function showDirectoryPicker() {
      return new Promise(async (resolve) => {
        const storage = getStorage();
        const home = await fetchHome();
        const defaultPath = storage.lastCwd || home;
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        overlay.innerHTML = '<div class="modal"><h2>Select working directory</h2><div class="path-wrap"><input type="text" id="cwd-input" value="' + defaultPath + '"><button class="path-up" id="up-btn">‚Üë</button><button class="new-folder" id="new-btn">+</button></div><div class="dir-tree" id="dir-tree"></div><label><input type="checkbox" id="always-use" ' + (storage.alwaysUse ? 'checked' : '') + '>Always use this directory</label><div class="modal-buttons"><button class="btn-secondary" id="cancel-btn">Cancel</button><button class="btn-primary" id="start-btn">Start</button></div></div>';
        document.body.appendChild(overlay);
        const input = overlay.querySelector('#cwd-input'), checkbox = overlay.querySelector('#always-use'), tree = overlay.querySelector('#dir-tree'), upBtn = overlay.querySelector('#up-btn'), newBtn = overlay.querySelector('#new-btn');
        async function refreshTree() {
          const r = await fetchDirs(input.value + '/');
          if (!r.dirs.length) { tree.innerHTML = '<div class="dir-empty">No subdirectories</div>'; }
          else {
            tree.innerHTML = r.dirs.map(d => '<div class="dir-item" data-path="' + d + '"><span class="dir-icon">üìÅ</span>' + d.split('/').pop() + '</div>').join('');
            tree.querySelectorAll('.dir-item').forEach(el => {
              el.onclick = () => { input.value = el.dataset.path; refreshTree(); };
              el.ondblclick = () => { input.value = el.dataset.path; submit(); };
            });
          }
        }
        function goUp() { const p = input.value.split('/'); if (p.length > 1) { p.pop(); input.value = p.join('/') || '/'; refreshTree(); } }
        upBtn.onclick = goUp;
        newBtn.onclick = async () => {
          const name = prompt('New folder name:');
          if (!name) return;
          const newPath = input.value + '/' + name;
          try {
            const res = await fetch('/api/mkdir', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ path: newPath }) });
            if (res.ok) { input.value = newPath; refreshTree(); }
            else { const err = await res.json(); alert('Failed: ' + err.error); }
          } catch (e) { alert('Failed: ' + e.message); }
        };
        let debounce; input.oninput = () => { clearTimeout(debounce); debounce = setTimeout(refreshTree, 300); };
        input.onkeydown = (e) => { if (e.key === 'Enter') submit(); else if (e.key === 'Escape') cancel(); };
        function submit() { const cwd = input.value.trim() || home; setStorage({ lastCwd: cwd, alwaysUse: checkbox.checked }); overlay.remove(); resolve(cwd); }
        function cancel() { overlay.remove(); resolve(null); }
        overlay.querySelector('#start-btn').onclick = submit;
        overlay.querySelector('#cancel-btn').onclick = cancel;
        overlay.onclick = (e) => { if (e.target === overlay) cancel(); };
        refreshTree();
      });
    }
    async function promptAndCreateSession() {
      const storage = getStorage();
      let cwd;
      if (storage.alwaysUse && storage.lastCwd) { cwd = storage.lastCwd; }
      else { cwd = await showDirectoryPicker(); if (cwd === null) return; }
      createSession(cwd, null, true);
    }
    document.getElementById('new-btn').addEventListener('click', () => promptAndCreateSession());
    function createSession(cwd, existingId = null, isNew = false) {
      const params = new URLSearchParams();
      if (existingId) params.set('id', existingId);
      if (cwd) params.set('cwd', cwd);
      if (isNew) params.set('new', '1');
      const ws = new WebSocket('ws://' + location.host + '?' + params);
      ws.onmessage = (e) => {
        try {
          const msg = JSON.parse(e.data);
          if (msg.type === 'session') { initTerminal(msg.id, ws, cwd); return; }
          if (msg.type === 'gone') {
            // Session no longer exists on server - remove from storage
            const storage = getStorage();
            setStorage({ sessions: (storage.sessions || []).filter(s => s.id !== msg.id) });
            return;
          }
        } catch {}
        const session = [...sessions.values()].find(s => s.ws === ws);
        if (session) session.term.write(e.data);
      };
      ws.onerror = () => { if (existingId) { const storage = getStorage(); setStorage({ sessions: (storage.sessions || []).filter(s => s.id !== existingId) }); } };
    }
    function initTerminal(id, ws, cwd) {
      const container = document.createElement('div');
      container.className = 'terminal-container';
      container.id = 'term-' + id;
      document.getElementById('terminals').appendChild(container);
      const term = new Terminal({ fontSize: 14, cursorBlink: true, theme: { background: '#0d1117' } });
      const fit = new FitAddon.FitAddon();
      term.loadAddon(fit);
      term.open(container);
      ws.onmessage = (e) => term.write(e.data);
      term.onData((data) => ws.send(data));
      term.attachCustomKeyEventHandler((event) => {
        if (event.shiftKey && event.key === 'Enter' && event.type === 'keydown') {
          // Send CSI u escape sequence for Shift+Enter (like iTerm2)
          ws.send('\x1b[13;2u');
          return false;
        }
        return true;
      });
      // Ensure terminal gets focus when clicked
      container.addEventListener('click', () => term.focus());
      sessions.set(id, { term, fit, ws, container, cwd });
      addTab(id);
      switchTo(id);
      const storage = getStorage();
      const saved = storage.sessions || [];
      if (!saved.find(s => s.id === id)) { saved.push({ id, cwd, name: sessions.get(id)?.name }); setStorage({ sessions: saved }); }
      requestAnimationFrame(() => { fit.fit(); ws.send(JSON.stringify({ type: 'resize', cols: term.cols, rows: term.rows })); });
      window.addEventListener('resize', () => { if (activeId === id) { fit.fit(); ws.send(JSON.stringify({ type: 'resize', cols: term.cols, rows: term.rows })); } });
    }
    function addTab(id) {
      const session = sessions.get(id);
      const savedName = getSavedSessionName(id);
      const displayName = savedName || getDefaultTabName(session?.cwd);
      if (session) session.name = displayName;

      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.id = 'tab-' + id;
      tab.innerHTML = '<span class="tab-label">' + displayName + '</span><span class="close">‚úï</span>';
      tab.querySelector('.tab-label').addEventListener('click', () => switchTo(id));
      tab.querySelector('.close').addEventListener('click', (e) => { e.stopPropagation(); killSession(id); });
      tab.addEventListener('contextmenu', (e) => { e.preventDefault(); TabContextMenu.show(e.clientX, e.clientY, id); });
      document.getElementById('new-btn').before(tab);
    }
    function switchTo(id) {
      if (activeId) { sessions.get(activeId)?.container.classList.remove('active'); document.getElementById('tab-' + activeId)?.classList.remove('active'); }
      activeId = id;
      const s = sessions.get(id);
      s.container.classList.add('active');
      document.getElementById('tab-' + id).classList.add('active');
      requestAnimationFrame(() => { s.fit.fit(); s.term.focus(); });
    }
    function killSession(id) {
      const s = sessions.get(id);
      if (!s) return;
      s.ws.close(); s.term.dispose(); s.container.remove();
      document.getElementById('tab-' + id).remove();
      sessions.delete(id);
      const storage = getStorage();
      setStorage({ sessions: (storage.sessions || []).filter(x => x.id !== id) });
      if (activeId === id) { const next = sessions.keys().next().value; if (next) switchTo(next); else activeId = null; }
    }
    (async function init() {
      const storage = getStorage();
      const saved = storage.sessions || [];
      if (saved.length > 0) { for (const { id, cwd } of saved) { createSession(cwd, id); } }
      else { await promptAndCreateSession(); }
    })();
  </script>
</body>
</html>
